1. Initialized Dispatcher Servlet -> created web application context
2. Initialized Context Load Listener -> created Root configuration(root appln context)
3. Created Home Controller -> maps the requests to "/" to home.jsp
4. Packaged this project as a .war file
    4.1 issues with "cannot access ServletException", added javax.servlet-api to pom
    4.2 issues with creating mock mvc, added spring-test to pom
    4.3 I also tried making a jar file, but jars need executables, so it looks for p.s.v.m
    4.3 so we need a war file, which we can put to webapps folder of a web server, added packaging to pom
    4.4 downloaded tomcat and got to ~tomcat-8.0/bin -> catalina.bat start
    4.5 add the packaged war file to webapps folder of tomcat download
    4.6 run localhost:8080/dir_name/
    4.6 failed, tomcat looks for web.xml configuration file, but we did all config in java
    4.7 we created WebConfig class as a alternative to web.xml
    4.8 we need to tell tomcat to ignore the web.xml, added war plugin to pom
    4.7 failed with error: The absolute uri: [http://java.sun.com/jsp/jstl/core] cannot be resolved
    4.8 we are using jstl in our jsp file(1st line), added jstl support in pom


5. Now we need to pull data of recent spittles from db, define a repository for data access.
6. We defined a repository, created a controller that maps to /spittles and tested it out.
7. Added a way to pass query parameters to the controller to get more specific results
8. if we want one specific spittle, we can use query parameters, but its not ideal
    8.1 ideally, As a general rule, query parameters should not be used to identify a resource.
                 A GET request for /spittles/12345 is better than one for /spittles/show?spittle_id=12345.
                 The former identifies a resource to be retrieved.
                 The latter describes an operation with a parameter—essentially RPC over HTTP.
9. form post feature added, and tested
    9.1 test failed because we did not have a default constructor for Spitter.
    9.2 It is used by spring when the post request send the Spitter object to postRegistrationForm()
        to build the object from the parameters submitted in the form
10. added validation to form parameters in Spitter using the javax.validation:validation-api.

===================================================================================================
Problems with jsp:
1. most jsp templates are littered with jsp tag libraries
2. if we view a jsp file unrendered its a visual disaster
3. jsp is a specification tightly coupled to servlet specification
4. It can only be used in web views in a servlet based web application(biggest problem)

Thymeleaf:
1. can be rendered wherever html can be rendered
2. natural templates
3. they’re not coupled to the servlet specification
4. when you open a thymeleaf template normally - it will make display properly
   by making conversions th:href to href. So you can ask someone who knows only html
   to generate these natural templates and then you can add the dynamic part anytime.

Configuring thymeleaf:
A ThymeleafViewResolver that resolves Thymeleaf template views from logical
view names
A SpringTemplateEngine to process the templates and render the results
A TemplateResolver that loads Thymeleaf templates

Issues Faced:
needed proper thymeleaf dependencies
http://www.thymeleaf.org/doc/articles/thymeleaf3migration.html

Thymeleaf Documentation:
http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#using-and-displaying-variables

Next:
Form binding in thymeleaf

==================================================================================================
Spring Web Flow







